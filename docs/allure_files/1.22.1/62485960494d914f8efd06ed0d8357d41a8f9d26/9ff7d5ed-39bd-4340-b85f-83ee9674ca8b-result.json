{"name": "test_reward_addr_delegation", "status": "broken", "statusDetails": {"message": "KeyError: 41", "trace": "self = <cardano_node_tests.tests.test_staking.TestRewards object at 0x7f10ad431ac0>, cluster_manager = <cardano_node_tests.utils.parallel_run.ClusterManager object at 0x7f10ad9cc5b0>, cluster_lock_pool2 = <cardano_node_tests.utils.clusterlib.ClusterLib object at 0x7f10ad9ccb80>\n\n    @allure.link(helpers.get_vcs_link())\n    def test_reward_addr_delegation(  # noqa: C901\n        self,\n        cluster_manager: parallel_run.ClusterManager,\n        cluster_lock_pool2: clusterlib.ClusterLib,\n    ):\n        \"\"\"Check that the rewards address can be delegated and receive rewards.\n    \n        Tests https://github.com/input-output-hk/cardano-node/issues/1964\n        \"\"\"\n        # pylint: disable=too-many-statements,too-many-locals\n        pool_name = \"node-pool2\"\n        cluster = cluster_lock_pool2\n    \n        temp_template = helpers.get_func_name()\n        pool_rec = cluster_manager.cache.addrs_data[pool_name]\n        pool_owner = clusterlib.PoolUser(payment=pool_rec[\"payment\"], stake=pool_rec[\"stake\"])\n        pool_reward = clusterlib.PoolUser(payment=pool_rec[\"payment\"], stake=pool_rec[\"reward\"])\n        reward_addr_dec = helpers.decode_bech32(pool_reward.stake.address)[2:]\n        stake_addr_dec = helpers.decode_bech32(pool_owner.stake.address)[2:]\n    \n        # fund pool owner's addresses so balance keeps higher than pool pledge after fees etc.\n        # are deducted\n        clusterlib_utils.fund_from_faucet(\n            pool_owner,\n            cluster_obj=cluster,\n            faucet_data=cluster_manager.cache.addrs_data[\"user1\"],\n            amount=150_000_000,\n            force=True,\n        )\n    \n        node_cold = pool_rec[\"cold_key_pair\"]\n        stake_pool_id = cluster.get_stake_pool_id(node_cold.vkey_file)\n    \n        # load and update original pool data\n        loaded_data = clusterlib_utils.load_registered_pool_data(\n            cluster_obj=cluster, pool_name=f\"changed_{pool_name}\", pool_id=stake_pool_id\n        )\n        pool_data_updated = loaded_data._replace(pool_pledge=0)\n    \n        # update the pool parameters by resubmitting the pool registration certificate\n        cluster.register_stake_pool(\n            pool_data=pool_data_updated,\n            pool_owners=[pool_owner],\n            vrf_vkey_file=pool_rec[\"vrf_key_pair\"].vkey_file,\n            cold_key_pair=pool_rec[\"cold_key_pair\"],\n            tx_name=f\"{temp_template}_update_param\",\n            reward_account_vkey_file=pool_rec[\"reward\"].vkey_file,\n            deposit=0,  # no additional deposit, the pool is already registered\n        )\n    \n        cluster_manager.set_needs_restart()  # changing pool configuration, restart needed\n    \n        sleep_time = clusterlib_utils.time_to_next_epoch_start(cluster) - 5\n        if sleep_time > 0:\n            time.sleep(sleep_time)\n    \n        init_epoch = cluster.get_last_block_epoch()\n        owner_rewards = [\n            (\n                init_epoch,\n                cluster.get_stake_addr_info(pool_reward.stake.address).reward_account_balance,\n                0,\n            )\n        ]\n    \n        # save ledger state\n        clusterlib_utils.save_ledger_state(\n            cluster_obj=cluster, name_template=f\"{temp_template}_{init_epoch}\"\n        )\n    \n        es_snapshots = {}\n        rs_records = {}\n        LOGGER.info(\"Checking rewards for 9 epochs.\")\n        for __ in range(9):\n            # reward balances in previous epoch\n            (\n                prev_epoch,\n                prev_owner_reward,\n                __,  # prev_abs_owner_reward\n            ) = owner_rewards[-1]\n    \n            # wait for new epoch\n            if cluster.get_last_block_epoch() == prev_epoch:\n                cluster.wait_for_new_epoch()\n    \n            # sleep till the end of epoch\n            sleep_time = clusterlib_utils.time_to_next_epoch_start(cluster) - 5\n            if sleep_time > 0:\n                time.sleep(sleep_time)\n    \n            this_epoch = cluster.get_last_block_epoch()\n    \n            # current reward balances\n            owner_reward = cluster.get_stake_addr_info(\n                pool_reward.stake.address\n            ).reward_account_balance\n    \n            # absolute reward amounts received this epoch\n            abs_owner_reward = (\n                owner_reward - prev_owner_reward if this_epoch == prev_epoch + 1 else 0\n            )\n    \n            # store collected rewards info\n            owner_rewards.append(\n                (\n                    this_epoch,\n                    owner_reward,\n                    abs_owner_reward,\n                )\n            )\n    \n            # save ledger state\n            clusterlib_utils.save_ledger_state(\n                cluster_obj=cluster, name_template=f\"{temp_template}_{this_epoch}\"\n            )\n            ledger_state: dict = cluster.get_ledger_state()\n            es_snapshot: dict = ledger_state[\"nesEs\"][\"esSnapshots\"]\n            es_snapshots[this_epoch] = es_snapshot\n            rs_record: list = ledger_state[\"nesRu\"][\"rs\"]\n            rs_records[this_epoch] = rs_record\n    \n            # Make sure reward amount corresponds with ledger state.\n            # Reward is received on epoch boundary, so check reward with record for previous epoch.\n            if abs_owner_reward:\n>               assert abs_owner_reward == _get_val_for_key_hash(\n                    reward_addr_dec, rs_records[this_epoch - 1]\n                )\nE               KeyError: 41\n\n/home/martink/Source/repos/cardano-node-tests2/cardano_node_tests/tests/test_staking.py:918: KeyError"}, "description": "Check that the rewards address can be delegated and receive rewards.\n\n        Tests https://github.com/input-output-hk/cardano-node/issues/1964\n        ", "attachments": [{"name": "log", "source": "15620965-6ec3-45ac-95c5-dba8a912baa1-attachment.txt", "type": "text/plain"}], "start": 1604689131403, "stop": 1604689495446, "uuid": "3ba6d807-4d30-490b-810a-ac15f860c9bc", "historyId": "5f3eefc6b7de9c92cd907cdb66f77adc", "testCaseId": "65edc76f066b043e48f3350014a7ac91", "fullName": "cardano_node_tests.tests.test_staking.TestRewards#test_reward_addr_delegation", "labels": [{"name": "tag", "value": "@pytest.mark.usefixtures('temp_dir')"}, {"name": "parentSuite", "value": "cardano_node_tests.tests"}, {"name": "suite", "value": "test_staking"}, {"name": "subSuite", "value": "TestRewards"}, {"name": "host", "value": "bender-3900x"}, {"name": "thread", "value": "372800-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "cardano_node_tests.tests.test_staking"}], "links": [{"type": "link", "url": "https://github.com/input-output-hk/cardano-node-tests/blob/2469c31cf82ae27863e9c0f51580385f1471d017/cardano_node_tests/tests/test_staking.py#L794", "name": "https://github.com/input-output-hk/cardano-node-tests/blob/2469c31cf82ae27863e9c0f51580385f1471d017/cardano_node_tests/tests/test_staking.py#L794"}]}